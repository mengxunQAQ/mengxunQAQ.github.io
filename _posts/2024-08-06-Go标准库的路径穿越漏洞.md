---
layout:     post
title:     Go标准库的路径穿越漏洞
subtitle:   url.JoinPath的逻辑错误
date:       2024-08-06
author:     mengxun
header-img: img/bg/blue-raw.png
catalog: true
tags:
    - 安全
---


#### 0x01 漏洞背景

Go 的`net/url` 包在 go1.19 版本中引入了一个新的函数 [url.JoinPath](https://pkg.go.dev/net/url@go1.19#JoinPath) ，目的是用于拼接 URL-Path，并且清理路径中的 ./ 和 ../ 这种可能会造成路径穿越的内容，但由于逻辑编写时未考虑周全，导致在某些场景下并没有如预期般清理该内容（[cve-2022-32190](https://nvd.nist.gov/vuln/detail/cve-2022-32190)）。


#### 0x02 背后原因

先看下这块逻辑在修复前的[源码](https://github.com/golang/go/commit/dbb52cc9f3e83a3040f46c2ae7650c15ab342179)

```go
func (u *URL) JoinPath(elem ...string) *URL {
	url := *u
	if len(elem) > 0 {
		elem = append([]string{u.Path}, elem...)
		url.setPath(path.Join(elem...))
	}
	return &url
}
```

可以看到，这里的核心逻辑是 [path.Join](https://pkg.go.dev/path#Join)，而 `path.Join` 有一个特性：因为它本来就是处理文件系统路径的，所以会把 ../ 这种内容当成正常的路径来处理，比如

```go
fmt.Println(path.Join("/", "../x"))
fmt.Println(path.Join("", "../x"))
```

最后的结果会是
```
/x
../x
```

而恰恰是这个特性，最终导致了代码里的逻辑漏洞


#### 0x03 问题探究

在问题修复前的go版本（比如 1.19.0），执行如下代码便可复现该问题
```go
package main

import (
        "fmt"
        "net/url"
)

func main() {
        fmt.Println(url.JoinPath("https://go.dev", "../x"))
        fmt.Println(url.JoinPath("https://go.dev/", "../x"))
}
```

最终输出为

```shell
root@db21901fda4d:/home# go run main.go
https://go.dev/../x <nil>
https://go.dev/x <nil>
```

两行输出里，第一行结果异常，另一行结果则正常，这其实便是上面代码中的 `u.Path` 导致的

在 `url.JoinPath("https://go.dev", "../x")` 的执行流程里， `u.Path` 是空字符串，最终执行的逻辑相当于

```go
path.Join("", "../x")
```

而在 `url.JoinPath("https://go.dev/", "../x")` 的执行流程里， `u.Path` 是 `/`，最终执行的逻辑相当于

```go
path.Join("/", "../x")
```

就因为一个`/`的差别，最后完全是两种结果。


#### 0x04 小结

当时的[文档](https://pkg.go.dev/net/url@go1.19#JoinPath)很明确的声明了

> the resulting path cleaned of any ./ or ../ elements

因此会有程序使用该函数进行路径穿越的防御，但该函数在某些场景下会出现预期外的结果，从而导致防御可能被绕过。






