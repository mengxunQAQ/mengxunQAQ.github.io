---
layout:     post
title:     jwt经常被滥用的场景
subtitle:   不要乱用jwt
date:       2024-09-28
author:     mengxun
header-img: img/bg/red-tomato.png
catalog: true
tags:
    - 随笔
---





#### 0x01 前言

`jwt`这种认证方案，平常见过很多地方都在用于登录认证。但绝大多数人其实都是不知所以的滥用，甚至很多人会把这种方案用于web系统的登陆或者第三方调用API的认证，非常不合理

#### 0x02 概述

`jwt`无非是把信息存在payload里进行保存，再加上签名防止篡改，从而达到服务器无需存储相关信息的目的。此时服务器是无状态的，但 session 其实并未消失，只是从服务端转移到了客户端，即`Client Side Session`，恰恰因为这个特点，所以`jwt`用于认证有两个非常致命的点：

- 签发撤回：正是因为 session 没有存储在服务端，导致 jwt 是脱离了服务端的控制的，一旦签发，在 expire 过期之前，那么这个 jwt 一直有效，哪怕这个 jwt 被其他地方偷走使用，那么服务端也会认为它是合法的。要避免这个问题，就必须可以拉黑某些之前签发过的 jwt，使之无法正常使用，要实现这个功能，代码需要增加复杂度，拉黑的 jwt 也需要存储在服务端（服务端需要存东西了，从无状态变成有状态了，而且存拉黑的 jwt 的地方又变成了集中点，jwt 失去了本来的意义）
- 续签问题：如果web界面目前正在登录状态，而签发的 jwt 已经即将到期了，那么此时就需要把当前的 旧jwt 替换成一个 新jwt，否则用户过一会就会被退出登录，为了解决续签问题就要设计刷新机制，web界面周期性的调用refresh接口去获取新的 jwt

因此，`jwt`只适合那种`一次性`和`流通范围受限`的场景：

比如api网关签发 jwt，给下游的其他服务使用，避免下游的其他服务再去查询用户和权限等信息，下游服务用完即弃，等到下次又会是api网关生成的 新jwt。这种场景下，jwt 完全是服务端内部流通，不会流通到外部的客户端，所以不存在盗用的风险；又因为用完即弃，属于一次性的使用，所以也不存在续签的问题。

#### 0x03 总结

`jwt`能适用的场景其实还是比较有限的，用于web登陆或者第三方调用API的认证，属于典型的有了锤子看啥都像钉子，只要牵扯到认证就会想到 jwt，其实根本没思考清楚

